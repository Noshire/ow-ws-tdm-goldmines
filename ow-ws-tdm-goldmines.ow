settings
{
	main
	{
		Mode Name: "Goldmine TDM"
	}

	lobby
	{
		Map Rotation: Paused
		Max Team 1 Players: 3
		Max Team 2 Players: 3
	}

	modes
	{
		Team Deathmatch
		{
			enabled maps
			{
				Ilios Lighthouse
			}
		}

		General
		{
			Game Mode Start: Immediately
		}
	}

	workshop
	{
		Debug Mode: On
	}

	extensions
	{
		Beam Effects
		Beam Sounds
		Buff Status Effects
		Debuff Status Effects
		Buff and Debuff Sounds
		Energy Explosion Effects
		Kinetic Explosion Effects
		Explosion Sounds
		Play More Effects
	}
}

variables
{
	global:
		26: SpawnPositionTeamArray
		27: MinePositionArray
		28: ArrayIteratorA
		29: MineGoldMax
		30: MineGoldCountArray
		31: MineRadius
		32: MineGoldIncrementInterval
		33: MineGoldIncrementAmount
		34: MineGoldStart
		35: ArrayIteratorB
		36: DEBUG
		37: MinePlayerIntersectionArray2D
		38: RadiusPlayerProximityBuffer
		39: PlayerGoldHarvestInterval
		40: PlayerGoldHarvestAmountBase
		41: ScoreTeamArray
		42: ScoreLimitTeamArray
		43: ColorTeamArray
		44: PlayerGoldBaseDepositTimerMax
		45: TeamArray
		46: SpawnRadius

	player:
		26: TeamIndex
		27: MineInRangeArray
		28: ArrayIterator
		29: GoldCount
		30: GoldHarvestAmount
		31: GoldBaseDepositTimer
}

rule("Init@Global: ApplyWorkshopSettings: Teams")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.A = Workshop Setting Integer(Custom String("Teams"), Custom String("Score Limit"), 3000, 10, 100000, 0);
		Global.ScoreLimitTeamArray[0] = Global.A;
		Global.ScoreLimitTeamArray[1] = Global.A;
		Global.SpawnRadius = Workshop Setting Real(Custom String("Teams"), Custom String("Team Base Radius in Meters"), 5, 0.500, 15, 0);
	}
}

rule("Init@Global: ApplyWorkshopSettings: Players")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.PlayerGoldHarvestInterval = Workshop Setting Real(Custom String("Players"), Custom String(
			"Gold Harvest Interval in Seconds"), 0.500, 0.050, 60, 0);
		Global.PlayerGoldHarvestAmountBase = Workshop Setting Integer(Custom String("Players"), Custom String("Gold Harvest Amount Base"),
			3, 0, 1000, 0);
		Global.PlayerGoldBaseDepositTimerMax = Workshop Setting Real(Custom String("Players"), Custom String(
			"Gold Deposit Timer in Seconds"), 3, 0, 60, 0);
	}
}

rule("Init@Global: ApplyWorkshopSettings: Gold Mines")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.MineGoldMax = Workshop Setting Integer(Custom String("Gold Mines"), Custom String("Max. Gold per Mine"), 100, 10, 1000, 0);
		Global.MineRadius = Workshop Setting Real(Custom String("Gold Mines"), Custom String("Radius"), 2.500, 0.500, 15, 0);
		Global.MineGoldIncrementInterval = Workshop Setting Real(Custom String("Gold Mines"), Custom String(
			"Gold Increase Interval in Seconds"), 5, 0.100, 60, 0);
		Global.MineGoldIncrementAmount = Workshop Setting Integer(Custom String("Gold Mines"), Custom String("Gold Increase Amount"), 10,
			1, 100, 0);
		Global.MineGoldStart = Workshop Setting Integer(Custom String("Gold Mines"), Custom String("Initial Gold Amount"), 30, 0, 1000, 0);
	}
}

rule("Init@Global: ApplyWorkshopSettings: Dev")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.DEBUG = Workshop Setting Toggle(Custom String("Dev Tools"), Custom String("Debug Mode"), False, 0);
	}
}

rule("Init@Global: InitGlobalVars")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.SpawnPositionTeamArray = Array(Vector(336.461, -24.274, 22.927), Vector(290.193, -24.276, -88.772));
		Global.TeamArray = Array(Team 1, Team 2);
		Global.MinePositionArray = Array(Vector(329.230, -17.341, -56.517), Vector(341.309, -17.341, -27.567), Vector(332.087, -26.341,
			-95.429), Vector(370.586, -26.341, -1.469), Vector(317.227, -22.342, -22.655), Vector(307.874, -22.341, -43.050), Vector(
			357.681, -24.341, -51.111));
		Global.ScoreTeamArray = Array(0, 0);
		Global.ColorTeamArray = Array(Custom Color(39, 60, 219, 255), Custom Color(219, 39, 39, 255));
		Global.RadiusPlayerProximityBuffer = 0.500;
	}
}

rule("Init@Global: InitGameMode")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Disable Built-In Game Mode Completion;
		Disable Built-In Game Mode Scoring;
	}
}

rule("Init@Global: InitMines")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePositionArray), 1);
			Log To Inspector(Custom String("Mine at: {0}", Global.MinePositionArray[Global.ArrayIteratorA]));
			Global.ArrayIteratorB = Global.MineGoldCountArray[Global.ArrayIteratorA];
			Global.MineGoldCountArray[Global.ArrayIteratorA] = Global.MineGoldStart;
			Create Effect(All Players(All Teams), Sphere, Count Of(Global.MinePlayerIntersectionArray2D[Evaluate Once(Global.ArrayIteratorA)])
				== 0 ? Custom Color(242, 255, 66, 255) : Custom Color(219, 117, 39, 255), Global.MinePositionArray[Global.ArrayIteratorA],
				Global.MineRadius, Color);
			Create In-World Text(All Players(All Teams), Custom String("{0}/{1}", Global.MineGoldCountArray[Evaluate Once(
				Global.ArrayIteratorA)], Global.MineGoldMax), Global.MinePositionArray[Global.ArrayIteratorA] + Up * 2.500, 1,
				Clip Against Surfaces, String, Color(White), Default Visibility);
		End;
	}
}

rule("Init@Global: InitSpawns")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.SpawnPositionTeamArray), 1);
			Log To Inspector(Custom String("Spawn at: {0}", Global.SpawnPositionTeamArray[Global.ArrayIteratorA]));
			Create Effect(All Players(All Teams), Sphere, Global.ColorTeamArray[Global.ArrayIteratorA],
				Global.SpawnPositionTeamArray[Global.ArrayIteratorA], Global.SpawnRadius, None);
			disabled Create In-World Text(All Players(All Teams), Custom String("{0}/{1}", Global.MineGoldCountArray[Evaluate Once(
				Global.ArrayIteratorA)], Global.MineGoldMax), Global.MinePositionArray[Global.ArrayIteratorA] + Up * 2.500, 1,
				Clip Against Surfaces, String, Color(White), Default Visibility);
		End;
	}
}

rule("Init@Player: InitPlayerVars")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.GoldHarvestAmount = Global.PlayerGoldHarvestAmountBase;
	}
}

rule("Init@Global: HUD")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Create Progress Bar HUD Text(All Players(All Teams), 100 * Min(1, Global.ScoreTeamArray[0] / Global.ScoreLimitTeamArray[0]),
			Custom String("Blue Team: {0} / {1}", Global.ScoreTeamArray[0], Global.ScoreLimitTeamArray[0]), Left, 0,
			Global.ColorTeamArray[0], Global.ColorTeamArray[0], Values, Default Visibility);
		Create Progress Bar HUD Text(All Players(All Teams), 100 * Min(1, Global.ScoreTeamArray[1] / Global.ScoreLimitTeamArray[1]),
			Custom String("Red Team: {0} / {1}", Global.ScoreTeamArray[1], Global.ScoreLimitTeamArray[1]), Right, 0,
			Global.ColorTeamArray[1], Global.ColorTeamArray[1], Values, Default Visibility);
	}
}

rule("Init@Player: SetTeamIndex")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.TeamIndex = Team Of(Event Player) == Team 1 ? 0 : 1;
	}
}

rule("Init@Player: HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Disable Game Mode HUD(Event Player);
	}
}

rule("Respawn@Player: TeleportToSpawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Teleport(Event Player, Global.SpawnPositionTeamArray[Event Player.TeamIndex]);
	}
}

rule("Update@Global: UpdateMines")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Wait(Global.MineGoldIncrementInterval, Ignore Condition);
		Log To Inspector(Custom String("Increment Gold in all Mines by {0}", Global.MineGoldIncrementAmount));
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MineGoldCountArray), 1);
			Global.MineGoldCountArray[Global.ArrayIteratorA] = Min(Global.MineGoldMax,
				Global.MineGoldCountArray[Global.ArrayIteratorA] + Global.MineGoldIncrementAmount);
		End;
		Loop;
	}
}

rule("DEBUG:Interact@Player: TeleportToRandomMine")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DEBUG == True;
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		disabled For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePositionArray), 1);
		disabled Create Beam Effect(Event Player, Echo Focusing Beam, Event Player, Global.MinePositionArray[Global.ArrayIteratorA], Color(White),
			Visible To Position and Radius);
		disabled End;
		Teleport(Event Player, Random Value In Array(Global.MinePositionArray));
	}
}

rule("DEBUG:Init@Global: StartImmediately")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DEBUG == True;
	}

	actions
	{
		Set Match Time(6);
	}
}

disabled rule("Update@Player: UpdateMinesInRange")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		For Player Variable(Event Player, ArrayIterator, 0, Count Of(Global.MinePositionArray), 1);
			Event Player.MineInRangeArray[Event Player.ArrayIterator] = Distance Between(Position Of(Event Player),
				Global.MinePositionArray[Event Player.ArrayIterator]) <= Global.MineRadius;
		End;
		Loop;
	}
}

rule("Update@Global: UpdateMinePlayerIntersection")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePositionArray), 1);
			Global.MinePlayerIntersectionArray2D[Global.ArrayIteratorA] = Filtered Array(All Players(All Teams), Is Alive(
				Current Array Element) && Distance Between(Global.MinePositionArray[Global.ArrayIteratorA], Position Of(Current Array Element))
				<= Global.MineRadius + Global.RadiusPlayerProximityBuffer);
		End;
		Loop;
	}
}

rule("Update@Global: UpdateMinePlayerHarvest")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Wait(Global.PlayerGoldHarvestInterval, Ignore Condition);
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePlayerIntersectionArray2D), 1);
			"A shuffled array of all players within the Gold Mine's radius."
			Global.A = Randomized Array(Global.MinePlayerIntersectionArray2D[Global.ArrayIteratorA]);
			"The maximum harvestable gold."
			Global.B = Global.MineGoldCountArray[Global.ArrayIteratorA];
			For Global Variable(ArrayIteratorB, 0, Count Of(Global.A), 1);
				"The player to process."
				Global.D = Global.A[Global.ArrayIteratorB];
				Global.C = Min(Global.B, Global.D.GoldHarvestAmount);
				If(Global.C > 0);
					Global.D.GoldCount += Global.C;
					Global.MineGoldCountArray[Global.ArrayIteratorA] -= Global.C;
					Play Effect(Global.D, Buff Explosion Sound, Color(White), Position Of(Global.D), 100);
					Log To Inspector(Custom String("Player {0} Harvests {1} Gold from Mine {2}", Global.D, Global.C, Global.ArrayIteratorA));
				End;
			End;
		End;
		Loop;
	}
}

rule("Update@Player: UpdateGoldBaseDeposit")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		"Get EventPlayer's team index."
		Event Player.A = Team Of(Event Player) == Team 1 ? 0 : 1;
		"Get EventPlayer's team base location."
		Event Player.B = Global.SpawnPositionTeamArray[Event Player.A];
		If(Distance Between(Event Player.B, Position Of(Event Player)) <= Global.SpawnRadius + Global.RadiusPlayerProximityBuffer);
			If(Event Player.GoldCount > 0);
				Event Player.GoldBaseDepositTimer += 0.100;
				If(Event Player.GoldBaseDepositTimer >= Global.PlayerGoldBaseDepositTimerMax);
					Global.ScoreTeamArray[Event Player.A] += Event Player.GoldCount;
					Event Player.GoldCount = 0;
					Event Player.GoldBaseDepositTimer = 0;
				End;
			End;
		Else;
			"EventPlayer has left the team base; reset the timer."
			Event Player.GoldBaseDepositTimer = 0;
		End;
		Loop;
	}
}
settings
{
	main
	{
		Mode Name: "Goldmine TDM"
	}

	lobby
	{
		Map Rotation: Paused
		Max Team 1 Players: 3
		Max Team 2 Players: 3
	}

	modes
	{
		Team Deathmatch
		{
			enabled maps
			{
				Ilios Lighthouse
			}
		}

		General
		{
			Game Mode Start: Immediately
		}
	}

	workshop
	{
		Debug Mode: On
	}

	extensions
	{
		Beam Effects
		Beam Sounds
		Buff Status Effects
		Debuff Status Effects
		Buff and Debuff Sounds
		Energy Explosion Effects
		Kinetic Explosion Effects
		Explosion Sounds
		Play More Effects
	}
}

variables
{
	global:
		26: SpawnPositions
		27: MinePositionArray
		28: ArrayIteratorA
		29: MineGoldMax
		30: MineGoldCountArray
		31: MineRadius
		32: MineGoldIncrementInterval
		33: MineGoldIncrementAmount
		34: MineGoldStart
		35: ArrayIteratorB
		36: DEBUG
		37: MinePlayerIntersectionArray2D
		38: MineRadiusPlayerProximityBuffer
		39: PlayerGoldHarvestInterval
		40: PlayerGoldHarvestAmountBase

	player:
		26: TeamIndex
		27: MineInRangeArray
		28: ArrayIterator
		29: GoldCount
		30: GoldHarvestAmount
}

rule("Init@Global: ApplyWorkshopSettings: Players")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.PlayerGoldHarvestInterval = Workshop Setting Real(Custom String("Players"), Custom String(
			"Gold Harvest Interval in Seconds"), 0.500, 0.050, 60, 0);
		Global.PlayerGoldHarvestAmountBase = Workshop Setting Integer(Custom String("Players"), Custom String("Gold Harvest Amount Base"),
			3, 0, 1000, 0);
	}
}

rule("Init@Global: ApplyWorkshopSettings: Gold Mines")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.MineGoldMax = Workshop Setting Integer(Custom String("Gold Mines"), Custom String("Max. Gold per Mine"), 100, 10, 1000, 0);
		Global.MineRadius = Workshop Setting Real(Custom String("Gold Mines"), Custom String("Radius"), 2.500, 0.500, 15, 0);
		Global.MineGoldIncrementInterval = Workshop Setting Real(Custom String("Gold Mines"), Custom String(
			"Gold Increase Interval in Seconds"), 5, 0.100, 60, 0);
		Global.MineGoldIncrementAmount = Workshop Setting Integer(Custom String("Gold Mines"), Custom String("Gold Increase Amount"), 10,
			1, 100, 0);
		Global.MineGoldStart = Workshop Setting Integer(Custom String("Gold Mines"), Custom String("Initial Gold Amount"), 30, 0, 1000, 0);
	}
}

rule("Init@Global: ApplyWorkshopSettings: Dev")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.DEBUG = Workshop Setting Toggle(Custom String("Dev Tools"), Custom String("Debug Mode"), False, 0);
	}
}

rule("Init@Global: InitGlobalVars")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.SpawnPositions = Array(Vector(336.461, -24.274, 22.927), Vector(290.193, -24.276, -88.772));
		Global.MinePositionArray = Array(Vector(329.230, -17.341, -56.517), Vector(341.309, -17.341, -27.567), Vector(332.087, -26.341,
			-95.429), Vector(370.586, -26.341, -1.469), Vector(317.227, -22.342, -22.655), Vector(307.874, -22.341, -43.050), Vector(
			357.681, -24.341, -51.111));
		Global.MineRadiusPlayerProximityBuffer = 0.500;
	}
}

rule("Init@Global: InitMines")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		disabled Is Game In Progress == True;
	}

	actions
	{
		Wait(5, Ignore Condition);
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePositionArray), 1);
			Log To Inspector(Custom String("Mine at: {0}", Global.MinePositionArray[Global.ArrayIteratorA]));
			Global.ArrayIteratorB = Global.MineGoldCountArray[Global.ArrayIteratorA];
			Global.MineGoldCountArray[Global.ArrayIteratorA] = Global.MineGoldStart;
			Create Effect(All Players(All Teams), Sphere, Custom Color(191, 186, 33, 150), Global.MinePositionArray[Global.ArrayIteratorA],
				Global.MineRadius, None);
			Create In-World Text(All Players(All Teams), Custom String("{0}/{1}", Global.MineGoldCountArray[Evaluate Once(
				Global.ArrayIteratorA)], Global.MineGoldMax), Global.MinePositionArray[Global.ArrayIteratorA] + Up * 2.500, 1,
				Clip Against Surfaces, String, Color(White), Default Visibility);
		End;
	}
}

rule("Init@Player: InitPlayerVars")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.GoldHarvestAmount = Global.PlayerGoldHarvestAmountBase;
	}
}

rule("Init@Player: SetTeamIndex")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.TeamIndex = Team Of(Event Player) == Team 1 ? 0 : 1;
	}
}

rule("Respawn@Player: TeleportToSpawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Teleport(Event Player, Global.SpawnPositions[Event Player.TeamIndex]);
	}
}

rule("Update@Global: UpdateMines")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Wait(Global.MineGoldIncrementInterval, Ignore Condition);
		Log To Inspector(Custom String("Increment Gold in all Mines by {0}", Global.MineGoldIncrementAmount));
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MineGoldCountArray), 1);
			Global.MineGoldCountArray[Global.ArrayIteratorA] = Min(Global.MineGoldMax,
				Global.MineGoldCountArray[Global.ArrayIteratorA] + Global.MineGoldIncrementAmount);
		End;
		Loop;
	}
}

rule("DEBUG:Interact@Player: TeleportToRandomMine")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DEBUG == True;
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		disabled For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePositionArray), 1);
		disabled Create Beam Effect(Event Player, Echo Focusing Beam, Event Player, Global.MinePositionArray[Global.ArrayIteratorA], Color(White),
			Visible To Position and Radius);
		disabled End;
		Teleport(Event Player, Random Value In Array(Global.MinePositionArray));
	}
}

rule("DEBUG:Init@Global: StartImmediately")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DEBUG == True;
	}

	actions
	{
		Set Match Time(6);
	}
}

disabled rule("Update@Player: UpdateMinesInRange")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		For Player Variable(Event Player, ArrayIterator, 0, Count Of(Global.MinePositionArray), 1);
			Event Player.MineInRangeArray[Event Player.ArrayIterator] = Distance Between(Position Of(Event Player),
				Global.MinePositionArray[Event Player.ArrayIterator]) <= Global.MineRadius;
		End;
		Loop;
	}
}

rule("Update@Global: UpdateMinePlayerIntersection")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePositionArray), 1);
			Global.MinePlayerIntersectionArray2D[Global.ArrayIteratorA] = Filtered Array(All Players(All Teams), Is Alive(
				Current Array Element) && Distance Between(Global.MinePositionArray[Global.ArrayIteratorA], Position Of(Current Array Element))
				<= Global.MineRadius + Global.MineRadiusPlayerProximityBuffer);
		End;
		Loop;
	}
}

rule("Update@Global: UpdateMinePlayerHarvest")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Wait(Global.PlayerGoldHarvestInterval, Ignore Condition);
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePlayerIntersectionArray2D), 1);
			"A shuffled array of all players within the Gold Mine's radius."
			Global.A = Randomized Array(Global.MinePlayerIntersectionArray2D[Global.ArrayIteratorA]);
			"The maximum harvestable gold."
			Global.B = Global.MineGoldCountArray[Global.ArrayIteratorA];
			For Global Variable(ArrayIteratorB, 0, Count Of(Global.A), 1);
				"The player to process."
				Global.D = Global.A[Global.ArrayIteratorB];
				Global.C = Min(Global.B, Global.D.GoldHarvestAmount);
				If(Global.C > 0);
					Global.D.GoldCount += Global.C;
					Global.MineGoldCountArray[Global.ArrayIteratorA] -= Global.C;
					Play Effect(Global.D, Buff Explosion Sound, Color(White), Position Of(Global.D), 100);
					Log To Inspector(Custom String("Player {0} Harvests {1} Gold from Mine {2}", Global.D, Global.C, Global.ArrayIteratorA));
				End;
			End;
		End;
		Loop;
	}
}
settings
{
	main
	{
		Mode Name: "Goldmine TDM"
	}

	lobby
	{
		Map Rotation: Paused
		Max Team 1 Players: 3
		Max Team 2 Players: 3
	}

	modes
	{
		Team Deathmatch
		{
			enabled maps
			{
				Ilios Lighthouse
			}
		}

		General
		{
			Game Mode Start: Immediately
			Self Initiated Respawn: Off
		}
	}

	heroes
	{
		General
		{
			disabled heroes
			{
				Sombra
			}
		}
	}

	workshop
	{
		Debug Mode: On
	}

	extensions
	{
		Beam Effects
		Beam Sounds
		Buff Status Effects
		Debuff Status Effects
		Buff and Debuff Sounds
		Energy Explosion Effects
		Kinetic Explosion Effects
		Explosion Sounds
		Play More Effects
	}
}

variables
{
	global:
		26: SpawnPositionTeamArray
		27: MinePositionArray
		28: ArrayIteratorA
		29: MineGoldMax
		30: MineGoldCountArray
		31: MineRadius
		32: MineRespawnDuration
		33: MineRespawnTimerArray
		34: RespawningMineColor
		35: ArrayIteratorB
		36: DEBUG
		37: MinePlayerIntersectionArray2D
		38: RadiusPlayerProximityBuffer
		39: PlayerGoldHarvestInterval
		40: PlayerGoldHarvestAmountBase
		41: ScoreTeamArray
		42: ScoreLimitTeamArray
		43: ColorTeamArray
		44: PlayerEnterBaseTimerMax
		45: TeamArray
		46: SpawnRadius
		47: GoldColor
		48: PlayerDeathGoldDropRatio
		49: GoldLootOrbPositionArray
		50: GoldLootOrbValueArray
		51: GoldLootOrbEffectArray
		52: GoldLootOrbCollectionRadius
		53: GoldLootOrbVisualRadius
		54: GoldLootOrbSpawnQueue
		55: UpdateInterval
		56: PlayerGoldDepositPerFrame
		57: BaseColor
		63: TeamGoldHarvestAmountFactorArray
		64: EnableGoldHarvestBalancing

	player:
		26: TeamIndex
		27: ClosestHarvestingMine
		28: HUDArray
		29: GoldCount
		30: GoldHarvestAmount
		31: EnterBaseTimer
		32: ArrayIteratorA
		33: IsInBase
		34: GoldDepositSoundEffectId
		35: UltimateCharge
}

subroutines
{
	0: CalculateTeamHandicap
}
}

rule("DEBUG:Interact@Player: TeleportToRandomMine")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DEBUG == True;
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		disabled Create Effect(All Players(All Teams), Orb, Color(Red), Eye Position(Event Player), 0.200, Visible To);
		Teleport(Event Player, Random Value In Array(Global.MinePositionArray));
	}
}

rule("DEBUG:Init@Global: StartImmediately")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DEBUG == True;
	}

	actions
	{
		Set Match Time(6);
	}
}

rule("Init@Global: ApplyWorkshopSettings: General")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.A = Workshop Setting Integer(Custom String("General"), Custom String("Score Limit"), 3000, 10, 100000, 0);
		Global.ScoreLimitTeamArray[0] = Global.A;
		Global.ScoreLimitTeamArray[1] = Global.A;
		Global.SpawnRadius = Workshop Setting Real(Custom String("General"), Custom String("Team Base Radius"), 5, 0.500, 15, 0);
		Global.GoldLootOrbCollectionRadius = Workshop Setting Real(Custom String("General"), Custom String("Death Loot Collection Radius"),
			3, 0.500, 15, 0);
		Global.GoldLootOrbVisualRadius = Workshop Setting Real(Custom String("General"), Custom String("Death Loot Visual Radius"), 0.350,
			0.100, 15, 0);
		Global.EnableGoldHarvestBalancing = Workshop Setting Toggle(Custom String("General"), Custom String(
			"Gold Harvest Auto-Balancing (smaller teams harvest faster)"), True, 0);
	}
}

rule("Init@Global: ApplyWorkshopSettings: Players")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.PlayerGoldHarvestInterval = Workshop Setting Real(Custom String("Players"), Custom String(
			"Gold Harvest Interval in Seconds"), 0.500, 0.050, 60, 0);
		Global.PlayerGoldHarvestAmountBase = Workshop Setting Integer(Custom String("Players"), Custom String("Gold Harvest Amount Base"),
			10, 0, 1000, 0);
		Global.PlayerEnterBaseTimerMax = Workshop Setting Real(Custom String("Players"), Custom String("Gold Deposit Timer in Seconds"), 3,
			0, 60, 0);
		Global.PlayerDeathGoldDropRatio = Workshop Setting Real(Custom String("Players"), Custom String("Gold Drop Ratio"), 1, 0, 1, 0);
		Global.PlayerGoldDepositPerFrame = Workshop Setting Integer(Custom String("Player"), Custom String("Gold Deposit Speed"), 5, 1,
			100000, 0);
	}
}

rule("Init@Global: ApplyWorkshopSettings: Gold Mines")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.MineGoldMax = Workshop Setting Integer(Custom String("Gold Mines"), Custom String("Max. Gold per Mine"), 200, 10, 1000, 0);
		Global.MineRadius = Workshop Setting Real(Custom String("Gold Mines"), Custom String("Radius"), 2.500, 0.500, 15, 0);
		Global.MineRespawnDuration = Workshop Setting Real(Custom String("Gold Mines"), Custom String("Regeneration Duration in Seconds"),
			30, 1, 300, 0);
	}
}

rule("Init@Global: ApplyWorkshopSettings: Dev")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.DEBUG = Workshop Setting Toggle(Custom String("Dev Tools"), Custom String("Debug Mode"), False, 0);
	}
}

rule("Init@Global: Map: Ilios Lighthouse")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Current Map == Map(Ilios Lighthouse);
	}

	actions
	{
		Global.SpawnPositionTeamArray = Array(Vector(336.461, -24.274, 22.927), Vector(290.193, -24.276, -88.772));
		Global.MinePositionArray = Array(Vector(329.230, -17.341, -56.517), Vector(341.309, -17.341, -27.567), Vector(332.087, -26.341,
			-95.429), Vector(370.586, -26.341, -1.469), Vector(317.227, -22.342, -22.655), Vector(307.874, -22.341, -43.050), Vector(
			357.681, -24.341, -51.111));
	}
}

rule("Init@Global: InitGlobalVars")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.TeamArray = Array(Team 1, Team 2);
		Global.ScoreTeamArray = Array(0, 0);
		Global.RadiusPlayerProximityBuffer = 0.500;
		Global.GoldColor = Custom Color(242, 255, 66, 255);
		Global.ColorTeamArray = Array(Custom Color(39, 60, 219, 255), Custom Color(219, 39, 39, 255));
		Global.BaseColor = Custom Color(125, 255, 251, 255);
		Global.RespawningMineColor = Custom Color(18, 18, 18, 128);
		Global.UpdateInterval = 0.016;
		Call Subroutine(CalculateTeamHandicap);
	}
}

rule("Init@Global: InitGameMode")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Disable Built-In Game Mode Completion;
		Disable Built-In Game Mode Scoring;
		Pause Match Time;
	}
}

rule("Init@Global: InitMines")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePositionArray), 1);
			Log To Inspector(Custom String("Mine at: {0}", Global.MinePositionArray[Global.ArrayIteratorA]));
			Global.ArrayIteratorB = Global.MineGoldCountArray[Global.ArrayIteratorA];
			Global.MineRespawnTimerArray[Global.ArrayIteratorA] = 0;
			Global.MineGoldCountArray[Global.ArrayIteratorA] = Global.MineGoldMax;
			Create Effect(All Players(All Teams), Sphere, Global.MineGoldCountArray[Evaluate Once(Global.ArrayIteratorA)] == 0 ? Custom Color(
				0, 0, 0, 0) : (Count Of(Global.MinePlayerIntersectionArray2D[Evaluate Once(Global.ArrayIteratorA)]) == 0 ? Custom Color(242,
				255, 66, 255) : Custom Color(219, 117, 39, 255)), Global.MinePositionArray[Global.ArrayIteratorA], Global.MineRadius,
				Visible To and Color);
			Create Beam Effect(Count Of(Global.MinePlayerIntersectionArray2D[Evaluate Once(Global.ArrayIteratorA)]) > 0 ? All Players(
				All Teams) : Null, Omnic Slicer Beam, Global.MinePositionArray[Global.ArrayIteratorA] + Up * Global.MineRadius,
				Global.MinePositionArray[Global.ArrayIteratorA] + Up * 100, Global.GoldColor, Visible To);
			Create Progress Bar In-World Text(Filtered Array(All Players(All Teams), !Array Contains(
				Global.MinePlayerIntersectionArray2D[Evaluate Once(Global.ArrayIteratorA)], Current Array Element)),
				Global.MineGoldCountArray[Evaluate Once(Global.ArrayIteratorA)] > 0 ? 100 * Global.MineGoldCountArray[Evaluate Once(
				Global.ArrayIteratorA)] / Global.MineGoldMax : 100 * Global.MineRespawnTimerArray[Evaluate Once(Global.ArrayIteratorA)
				] / Global.MineRespawnDuration, Global.MineGoldCountArray[Evaluate Once(Global.ArrayIteratorA)] > 0 ? Custom String("{0}/{1}",
				Global.MineGoldCountArray[Evaluate Once(Global.ArrayIteratorA)], Global.MineGoldMax) : Custom String("Regenerating..."),
				Global.MinePositionArray[Global.ArrayIteratorA] + Up * 2.500, 0.350, Clip Against Surfaces,
				Global.MineGoldCountArray[Evaluate Once(Global.ArrayIteratorA)] > 0 ? Global.GoldColor : Global.RespawningMineColor,
				Global.MineGoldCountArray[Evaluate Once(Global.ArrayIteratorA)] > 0 ? Global.GoldColor : Global.RespawningMineColor,
				Visible To Values and Color, Default Visibility);
		End;
	}
}

rule("Init@Global: InitSpawns")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.SpawnPositionTeamArray), 1);
			Log To Inspector(Custom String("Spawn at: {0}", Global.SpawnPositionTeamArray[Global.ArrayIteratorA]));
			Create Effect(All Players(All Teams), Sphere, Global.ColorTeamArray[Global.ArrayIteratorA],
				Global.SpawnPositionTeamArray[Global.ArrayIteratorA], Global.SpawnRadius, Visible To);
		End;
	}
}

rule("Init@Player: InitPlayerVars")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.GoldHarvestAmount = Global.PlayerGoldHarvestAmountBase;
		Event Player.GoldCount = 0;
		disabled Event Player.IsInBase = True;
	}
}

rule("Init@Global: HUD")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Create Progress Bar HUD Text(All Players(All Teams), 100 * Min(1, Global.ScoreTeamArray[0] / Global.ScoreLimitTeamArray[0]),
			Custom String("Blue Team: {0} / {1}", Global.ScoreTeamArray[0], Global.ScoreLimitTeamArray[0]), Left, 0,
			Global.ColorTeamArray[0], Global.ColorTeamArray[0], Visible To and Values, Visible Always);
		Create Progress Bar HUD Text(All Players(All Teams), 100 * Min(1, Global.ScoreTeamArray[1] / Global.ScoreLimitTeamArray[1]),
			Custom String("Red Team: {0} / {1}", Global.ScoreTeamArray[1], Global.ScoreLimitTeamArray[1]), Right, 0,
			Global.ColorTeamArray[1], Global.ColorTeamArray[1], Visible To and Values, Visible Always);
		Create In-World Text(All Players(Team 1), Custom String("{0} Base", Icon String(Flag)),
			Global.SpawnPositionTeamArray[0] + Up * 2.500, 1.500, Do Not Clip, Visible To, Global.ColorTeamArray[0], Default Visibility);
		Create In-World Text(All Players(Team 2), Custom String("{0} Base", Icon String(Flag)),
			Global.SpawnPositionTeamArray[1] + Up * 2.500, 1.500, Do Not Clip, Visible To, Global.ColorTeamArray[1], Default Visibility);
	}
}

rule("Init@Player: SetTeamIndex")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.TeamIndex = Team Of(Event Player) == Team 1 ? 0 : 1;
	}
}

rule("Init@Player: HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Disable Game Mode HUD(Event Player);
		"Clean up any previous HUD texts, e.g. after swapping teams."
		For Player Variable(Event Player, ArrayIteratorA, 0, Count Of(Event Player.HUDArray), 1);
			Destroy HUD Text(Event Player.HUDArray[Event Player.ArrayIteratorA]);
		End;
		Event Player.HUDArray = Array();
		Create HUD Text(Event Player, Custom String("{0} {1} {0}", Icon String(Diamond), Event Player.GoldCount), Null, Null, Top, 0,
			Global.GoldColor, Color(White), Color(White), Visible To and String, Default Visibility);
		Modify Player Variable(Event Player, HUDArray, Append To Array, Last Text ID);
		Create Progress Bar HUD Text(Event Player.EnterBaseTimer > 0 ? Event Player : Null, 100 * Min(1,
			Event Player.EnterBaseTimer / Global.PlayerEnterBaseTimerMax), Custom String("Entering Base..."), Top, 1, Global.BaseColor,
			Global.BaseColor, Visible To Values and Color, Default Visibility);
		Modify Player Variable(Event Player, HUDArray, Append To Array, Last Text ID);
		Create Progress Bar HUD Text(Event Player.ClosestHarvestingMine > -1 ? Event Player : Null, 100 * Min(1,
			Global.MineGoldCountArray[Event Player.ClosestHarvestingMine] / Global.MineGoldMax), Custom String("{0} / {1}",
			Global.MineGoldCountArray[Event Player.ClosestHarvestingMine], Global.MineGoldMax), Top, 1, Global.GoldColor, Global.GoldColor,
			Visible To and Values, Default Visibility);
		Modify Player Variable(Event Player, HUDArray, Append To Array, Last Text ID);
		Create HUD Text(Event Player.IsInBase == True ? Event Player : Null, Custom String("{0} IN BASE {0}", Ability Icon String(Hero(
			Winston), Button(Ability 2))), Null, Null, Top, 2, Global.BaseColor, Global.BaseColor, Global.BaseColor, Visible To,
			Default Visibility);
		Modify Player Variable(Event Player, HUDArray, Append To Array, Last Text ID);
	}
}

rule("Update@Global: UpdateMineRespawn")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Wait(Global.UpdateInterval, Abort When False);
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MineRespawnTimerArray), 1);
			If(Global.MineGoldCountArray[Global.ArrayIteratorA] <= 0);
				Global.MineRespawnTimerArray[Global.ArrayIteratorA] = Min(Global.MineRespawnDuration,
					Global.MineRespawnTimerArray[Global.ArrayIteratorA] + Global.UpdateInterval);
				"If timer is complete, refill the gold."
				If(Global.MineRespawnTimerArray[Global.ArrayIteratorA] >= Global.MineRespawnDuration);
					Global.MineRespawnTimerArray[Global.ArrayIteratorA] = 0;
					Global.MineGoldCountArray[Global.ArrayIteratorA] = Global.MineGoldMax;
				End;
			End;
		End;
		Loop If Condition Is True;
	}
}

rule("Update@Global: UpdateMinePlayerIntersection")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Wait(0.100, Abort When False);
		"Clear the \"closest GoldMine in range\" for all players."
		For Global Variable(ArrayIteratorA, 0, Count Of(All Players(All Teams)), 1);
			All Players(All Teams)[Global.ArrayIteratorA].ClosestHarvestingMine = -1;
		End;
		"Loop through all GoldMines..."
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePositionArray), 1);
			"Update the list of players within range of this GoldMine."
			Global.MinePlayerIntersectionArray2D[Global.ArrayIteratorA] = Filtered Array(All Players(All Teams), Has Spawned(
				Current Array Element) && Is Alive(Current Array Element)
				&& Global.MineGoldCountArray[Global.ArrayIteratorA] > 0 && Distance Between(Global.MinePositionArray[Global.ArrayIteratorA],
				Position Of(Current Array Element)) <= Global.MineRadius + Global.RadiusPlayerProximityBuffer);
			"Loop through all players in range of this GoldMine..."
			For Global Variable(ArrayIteratorB, 0, Count Of(Global.MinePlayerIntersectionArray2D[Global.ArrayIteratorA]), 1);
				disabled Log To Inspector(Custom String("CheckDist: GoldMine {0}, Player {1}.", Global.ArrayIteratorA, Global.ArrayIteratorB));
				"Cache the Player to a temporary variable."
				Global.A = Global.MinePlayerIntersectionArray2D[Global.ArrayIteratorA][Global.ArrayIteratorB];
				Global.B = Distance Between(Position Of(Global.A), Global.MinePositionArray[Global.ArrayIteratorA]);
				Global.C = Global.A.ClosestHarvestingMine < 0 ? 99999 : Distance Between(Position Of(Global.A),
					Global.MinePositionArray[Global.A.ClosestHarvestingMine]);
				disabled Log To Inspector(Custom String("P: {0}, NextDist: {1}, MinDist: {2}", Global.A, Global.B, Custom String("{0}, ClosestMine: {1}",
					Global.C, Global.A.ClosestHarvestingMine)));
				"If the distance is less than the previous smallest distance between the player and a GoldMine..."
				If(Global.B < Global.C);
					"Set it as the closest GoldMine for this player."
					Global.A.ClosestHarvestingMine = Evaluate Once(Global.ArrayIteratorA);
					disabled Log To Inspector(Custom String("Set Closest Mine: Player: {0}, Mine: {1}", Global.A, Global.A.ClosestHarvestingMine));
				End;
			End;
		End;
		Loop If Condition Is True;
	}
}

rule("Update@Global: UpdateMinePlayerHarvest")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Wait(Global.PlayerGoldHarvestInterval, Ignore Condition);
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.MinePlayerIntersectionArray2D), 1);
			"A shuffled array of all players within the Gold Mine's radius."
			Global.A = Randomized Array(Global.MinePlayerIntersectionArray2D[Global.ArrayIteratorA]);
			"The maximum harvestable gold."
			Global.B = Global.MineGoldCountArray[Global.ArrayIteratorA];
			For Global Variable(ArrayIteratorB, 0, Count Of(Global.A), 1);
				"The player to process."
				Global.D = Global.A[Global.ArrayIteratorB];
				"The amount of gold to harvest."
				Global.C = Min(Global.B, Global.D.GoldHarvestAmount * Global.TeamGoldHarvestAmountFactorArray[Global.D.TeamIndex]);
				If(Global.C > 0);
					Global.D.GoldCount += Global.C;
					Global.MineGoldCountArray[Global.ArrayIteratorA] -= Global.C;
					Play Effect(Global.D, Buff Explosion Sound, Color(White), Position Of(Global.D), 100);
					disabled Log To Inspector(Custom String("Player {0} Harvests {1} Gold from Mine {2}", Global.D, Global.C, Global.ArrayIteratorA));
				End;
			End;
		End;
		Loop;
	}
}

rule("Update@Player: UpdateIsInBase")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Wait(Global.UpdateInterval, Abort When False);
		"Get EventPlayer's team base location."
		Event Player.B = Global.SpawnPositionTeamArray[Event Player.TeamIndex];
		"Bool indicating whether the event player is in the radius of their base."
		Event Player.C = Distance Between(Event Player.B, Position Of(Event Player))
			<= Global.SpawnRadius + Global.RadiusPlayerProximityBuffer;
		If(Event Player.C && !Event Player.IsInBase);
			Event Player.EnterBaseTimer += Global.UpdateInterval;
			If(Event Player.EnterBaseTimer >= Global.PlayerEnterBaseTimerMax);
				Event Player.EnterBaseTimer = 0;
				Event Player.IsInBase = True;
			End;
		Else If(!Event Player.C && (Event Player.IsInBase || Event Player.EnterBaseTimer > 0));
			"EventPlayer has left the team base; reset the timer."
			Event Player.EnterBaseTimer = 0;
			Event Player.IsInBase = False;
		End;
		Loop If Condition Is True;
	}
}

rule("Update@Player: UpdateGoldLootCollision")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Wait(0.100, Abort When False);
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.GoldLootOrbPositionArray), 1);
			disabled Log To Inspector(Custom String("{0}", Distance Between(Position Of(Event Player),
				Global.GoldLootOrbPositionArray[Global.ArrayIteratorA])));
			If(Distance Between(Position Of(Event Player), Global.GoldLootOrbPositionArray[Global.ArrayIteratorA])
				<= Global.GoldLootOrbCollectionRadius + Global.RadiusPlayerProximityBuffer);
				Destroy Effect(Global.GoldLootOrbEffectArray[Global.ArrayIteratorA]);
				Event Player.GoldCount += Global.GoldLootOrbValueArray[Global.ArrayIteratorA];
				Modify Global Variable(GoldLootOrbPositionArray, Remove From Array By Index, Global.ArrayIteratorA);
				Modify Global Variable(GoldLootOrbValueArray, Remove From Array By Index, Global.ArrayIteratorA);
				Modify Global Variable(GoldLootOrbEffectArray, Remove From Array By Index, Global.ArrayIteratorA);
				Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 100);
				Log To Inspector(Custom String("Destroy GoldLoot: {0}", Global.ArrayIteratorA));
			End;
		End;
		Loop If Condition Is True;
	}
}

rule("Update@Global: SpawnGoldLoot")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		"We can't create the Orbs directly in the OnPlayerDeath event, else they get bound to that player and destroyed when the player leaves or swaps teams. This \"worker thread\" moves it into global scope."
		For Global Variable(ArrayIteratorA, 0, Count Of(Global.GoldLootOrbSpawnQueue), 1);
			Modify Global Variable(GoldLootOrbPositionArray, Append To Array, Global.GoldLootOrbSpawnQueue[Global.ArrayIteratorA][0]);
			Modify Global Variable(GoldLootOrbValueArray, Append To Array, Global.GoldLootOrbSpawnQueue[Global.ArrayIteratorA][1]);
			Create Effect(All Players(All Teams), Orb, Global.GoldColor, Global.GoldLootOrbSpawnQueue[Global.ArrayIteratorA][0],
				Global.GoldLootOrbVisualRadius, Visible To);
			Modify Global Variable(GoldLootOrbEffectArray, Append To Array, Last Created Entity);
		End;
		Global.GoldLootOrbSpawnQueue = Array();
		Loop If Condition Is True;
	}
}

rule("OnDeath@Player: EnqueueGoldLootDrop")
{
	event
	{
		Player Died;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Event Player.A = Round To Integer(Event Player.GoldCount * Global.PlayerDeathGoldDropRatio, Down);
		Abort If(Event Player.A == 0);
		Event Player.B = Array(Evaluate Once(Nearest Walkable Position(Evaluate Once(Position Of(Event Player)))), Evaluate Once(
			Event Player.A));
		"Enqueue a GoldLoot spawn command."
		Global.GoldLootOrbSpawnQueue[Count Of(Global.GoldLootOrbSpawnQueue)] = Event Player.B;
		Event Player.GoldCount -= Event Player.A;
	}
}

rule("OnRespawn@Player: TeleportToSpawn")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Teleport(Event Player, Global.SpawnPositionTeamArray[Event Player.TeamIndex]);
	}
}

rule("OnRespawn@Player: SetIsInBase")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Event Player.IsInBase = True;
	}
}

rule("OnJoinedMatch@Player: CalculateTeamHandicap")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	actions
	{
		Log To Inspector(Custom String("Player {0} joined the match.", Event Player));
		Call Subroutine(CalculateTeamHandicap);
	}
}

rule("OnLeftMatch@Player: CalculateTeamHandicap")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	actions
	{
		Log To Inspector(Custom String("Player {0} left the match.", Event Player));
		Call Subroutine(CalculateTeamHandicap);
	}
}

rule("OnScoreChanged@Team1: CheckWinCondition")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.ScoreTeamArray[0] >= Global.ScoreLimitTeamArray[0];
	}

	actions
	{
		Declare Team Victory(Team 1);
	}
}

rule("OnScoreChanged@Team2: CheckWinCondition")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.ScoreTeamArray[1] >= Global.ScoreLimitTeamArray[1];
	}

	actions
	{
		Declare Team Victory(Team 2);
	}
}

rule("OnBaseEntered@Player: Shelter")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.IsInBase == True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.UltimateCharge = Ultimate Charge Percent(Event Player);
		Set Invisible(Event Player, Enemies);
		Set Status(Event Player, Null, Invincible, 9999);
		Start Heal Over Time(Event Player, Event Player, 9999, 25);
		Set Ability 1 Enabled(Event Player, False);
		Set Ability 2 Enabled(Event Player, False);
		Set Melee Enabled(Event Player, False);
		Set Ultimate Ability Enabled(Event Player, False);
		Set Primary Fire Enabled(Event Player, False);
		Set Secondary Fire Enabled(Event Player, False);
	}
}

rule("OnBaseLeft@Player: Unshelter")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.IsInBase == False;
	}

	actions
	{
		Set Invisible(Event Player, None);
		Clear Status(Event Player, Invincible);
		Stop All Heal Over Time(Event Player);
		Set Ability 1 Enabled(Event Player, True);
		Set Ability 2 Enabled(Event Player, True);
		Set Melee Enabled(Event Player, True);
		Set Ultimate Ability Enabled(Event Player, True);
		Set Primary Fire Enabled(Event Player, True);
		Set Secondary Fire Enabled(Event Player, True);
		Set Ultimate Charge(Event Player, Event Player.UltimateCharge);
	}
}

rule("Update@Player: DepositGoldInBase")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Alive(Event Player) == True;
		Event Player.IsInBase == True;
		Event Player.GoldCount > 0;
	}

	actions
	{
		disabled Create Effect(Event Player, Energy Sound, Color(White), Eye Position(Event Player), 200, Visible To Position and Radius);
		disabled Event Player.GoldDepositSoundEffectId = Last Created Entity;
		While(True);
			Wait(Global.UpdateInterval, Abort When False);
			Abort If Condition Is False;
			Event Player.A = Min(Global.PlayerGoldDepositPerFrame, Event Player.GoldCount);
			Event Player.GoldCount -= Event Player.A;
			Global.ScoreTeamArray[Event Player.TeamIndex] += Event Player.A;
			If(Event Player.GoldCount <= 0);
				Play Effect(Global.D, Buff Explosion Sound, Color(White), Position Of(Global.D), 100);
			End;
		End;
		disabled Destroy Effect(Event Player.GoldDepositSoundEffectId);
	}
}

rule("Subroutine: CalculateTeamHandicap")
{
	event
	{
		Subroutine;
		CalculateTeamHandicap;
	}

	actions
	{
		If(Global.EnableGoldHarvestBalancing == False);
			Global.TeamGoldHarvestAmountFactorArray = Array(1, 1);
			Abort;
		End;
		Global.A = Max(1, Count Of(All Players(Team 1)));
		Global.B = Max(1, Count Of(All Players(Team 2)));
		Global.TeamGoldHarvestAmountFactorArray[0] = Max(1, Global.B / Global.A);
		Global.TeamGoldHarvestAmountFactorArray[1] = Max(1, Global.A / Global.B);
		Log To Inspector(Custom String("Team 1: Players={0}, GoldHarvestFactor={1}", Count Of(All Players(Team 1)),
			Global.TeamGoldHarvestAmountFactorArray[0]));
		Log To Inspector(Custom String("Team 2: Players={0}, GoldHarvestFactor={1}", Count Of(All Players(Team 2)),
			Global.TeamGoldHarvestAmountFactorArray[1]));
	}
}